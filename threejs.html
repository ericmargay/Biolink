<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>three.js - depth-of-field</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    let camera, scene, renderer,
        parameters, nobjects, cubeMaterial;

    let mouseX = 0, mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let width = window.innerWidth;
    let height = window.innerHeight;

    const materials = [];
    const postprocessing = {};

    init();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, width / height, 1, 3000);
      camera.position.z = 200;

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);
      renderer.autoClear = false;
      document.body.appendChild(renderer.domElement);

      // Cargar cubemap desde CDN oficial
      const base = 'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/';
      const urls = ['px','nx','py','ny','pz','nz'].map(face => `${base}${face}.jpg`);
      const textureCube = new THREE.CubeTextureLoader().load(urls);
      if (textureCube.colorSpace !== undefined) textureCube.colorSpace = THREE.SRGBColorSpace;

      parameters = { color: 0xff4900, envMap: textureCube };
      cubeMaterial = new THREE.MeshBasicMaterial(parameters);

      const geo = new THREE.SphereGeometry(1, 20, 10);
      const xgrid = 14, ygrid = 9, zgrid = 14;
      nobjects = xgrid * ygrid * zgrid;

      const s = 60;
      let count = 0;

      for (let i = 0; i < xgrid; i++) {
        for (let j = 0; j < ygrid; j++) {
          for (let k = 0; k < zgrid; k++) {
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial(parameters));
            materials[count] = mesh.material;

            const x = 200 * (i - xgrid / 2);
            const y = 200 * (j - ygrid / 2);
            const z = 200 * (k - zgrid / 2);

            mesh.position.set(x, y, z);
            mesh.scale.set(s, s, s);
            mesh.matrixAutoUpdate = false;
            mesh.updateMatrix();

            scene.add(mesh);
            count++;
          }
        }
      }

      initPostprocessing();

      document.body.style.touchAction = 'none';
      document.body.addEventListener('pointermove', onPointerMove);
      window.addEventListener('resize', onWindowResize);

      renderer.setAnimationLoop(animate);
    }

    function onPointerMove(event) {
      if (event.isPrimary === false) return;
      mouseX = event.clientX - windowHalfX;
      mouseY = event.clientY - windowHalfY;
    }

    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      width = window.innerWidth;
      height = window.innerHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      postprocessing.composer.setSize(width, height);
    }

    function initPostprocessing() {
      const renderPass = new RenderPass(scene, camera);
      const bokehPass = new BokehPass(scene, camera, {
        focus: 500.0,
        aperture: 0.00005,
        maxblur: 0.01
      });
      const outputPass = new OutputPass();

      const composer = new EffectComposer(renderer);
      composer.addPass(renderPass);
      composer.addPass(bokehPass);
      composer.addPass(outputPass);

      postprocessing.composer = composer;
      postprocessing.bokeh = bokehPass;
    }

    function animate() {
      render();
    }

    function render() {
      const time = Date.now() * 0.00005;

      camera.position.x += (mouseX - camera.position.x) * 0.036;
      camera.position.y += (-(mouseY) - camera.position.y) * 0.036;
      camera.lookAt(scene.position);

      for (let i = 0; i < nobjects; i++) {
        const h = (360 * (i / nobjects + time) % 360) / 360;
        materials[i].color.setHSL(h, 1, 0.5);
      }

      postprocessing.composer.render(0.1);
    }
  </script>
</body>
</html>
